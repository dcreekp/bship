""" dictionary for a board """
    brd = {'A1': [(1,1), 'O'], 'A2': [(1,2), 'O']}

    brd['A2'][1] = '@'

    assert brd['A1'][0] == (1,1)
    assert brd['A1'][0][0] == 1
    assert brd['A2'][1] == '@'
    assert brd['A2'][0][1] == 2
    
    g1 = [(i,j) for i in range(1,10) for j in range(1,10)]
    g2 = ['O']  * 81
    #grid = OrderedDict({(1,1): 'O', (1,2): 'O', (1,3): 'O', (2,1): 'O', (2,2): 'O', (2,3): 'O'})
    grid = OrderedDict(zip(g1,g2))

    print 'grid', grid
    assert grid[(1,1)] == 'O'
    
    assert grid.keys()[0] == (1,1)
    assert grid.keys()[1][0] == 1
    assert grid.keys()[1][1] == 2
    assert grid.keys()[1][1] + 1 == 3

    print grid[(2,2)]

    grid[(2,2)] = 'X'

    print 'grid[(3,3)]', grid[(3,3)]

    """ display of brd """

    grd = list(grid.values())

    print "list the grid", grd


    

    #brd = [grd[0:9],grd[10:19]]

    #brd = [[i] for i in ]

    brd = [grd[i:i+9] for i in range(0, len(grd), 9)]
    #for i in range(0, len(grd), 9):
       # d = grd[i:i+9]
        #brd.append(d)

    for i,j in zip('ABCDEFGHI', range(9)):
        brd[j].insert(0,i)

    print brd

    print list(i for i in '+123456789')
    print [i for i in '+123456789']

    brd.insert(0, [i for i in '+123456789'])

    print brd

    for row in brd:
        print '\t' + ' '.join(row)

"""another board"""

    g_key = [i+str(j) for i in 'ABCDEFGHI' for j in range(1,10)]
    g_value = [[(i,j), 'O'] for i in range(1,10) for j in range(1,10)]

    board = OrderedDict(zip(g_key, g_value))

    print board
    print board.values()

    board['A1'][1] = 'X'
    board.values()[2][1] = '@'
    lst = list(board.values()[i][1] for i in range(len(board)))
    print lst

""" convert string to grid ref tuple"""

    def con(coord):
        """ 'A1' to (1,1) """
        sint = dict(zip((i for i in 'ABCDEFGHI'),range(1,10)))
        
        return (sint[coord[0]], int(coord[1]))
    
    assert con('A1') == (1,1)   
    print "con('G5')", con('G5')

    def rcon(coord):
        """ (1,1) to 'A1' """
        istr = dict(zip(range(1,10), (i for i in 'ABCDEFGHI')))
        
        return istr[coord[0]] + str(coord[1])

    assert rcon((3,2)) == 'C2'
    print "rcon((2,2))", rcon((2,2))


#from collections import OrderedDict


class Board(object):


    ATTACK = [] #OrderedDict()
    DEFEND = [] #OrderedDict()   

    def __init__(self, n=9):
        """ creates a new board database; an ordered dictionary of grid coord 
            and their value as open/miss/hit status O X # @ $
        """

        # problem with this structure will be that it is hard to get the computer to recognise 
        # the boundaries of the board
        # possible solution is to have it as a list of rows which are ordered dictionaries
        # actually list of OrderedDict provides little advantage because can't index call
        # so list of lists may in the end be better
        '''
        g_key = tuple(i + str(j) for i in 'ABCDEFGHI'[:n] for j in range(1,n+1)) 
            # generates A1, A2 and so on, needs to be a tuple to store the generated 
        g_value = 'O' * (n**2) # dictionary value is the coord's hit status

        self.ATTACK = OrderedDict(zip(g_key, g_value))
        self.DEFEND = OrderedDict(zip(g_key, g_value))    
        '''

        self.ATTACK = [['O'] * n for i in range(n)]
        self.DEFEND = [['O'] * n for i in range(n)]
        
        

    def display(self, n=9):
        """ converts board from a database to a displayable brd on the CLI console
            and prints it
        """
        '''
        alst = list(self.ATTACK.values()) # turns the dict values into a list check if already list
        dlst = list(self.DEFEND.values())

        abrd = [alst[i:i+n] for i in range(0, len(alst), n)] 
        dbrd = [dlst[i:i+n] for i in range(0, len(dlst), n)]
        # turns the list into a list of lists by splitting the values by length n of the board

        self._add_border(abrd, n) # adds visual features to the board
        self._add_border(dbrd, n)
        '''

        self._add_border(self.ATTACK, n)
        self._add_border(self.DEFEND, n)


        print '\t' + 'ATTACK'
        for row in abrd:                    # prints per row
            print '\t\t' + ' '.join(row)

        print '\t' + 'DEFEND'
        for row in dbrd:
            print '\t\t' + ' '.join(row)


    def change_point(self):

        pass
        '''
        O -> X
        # -> @
        all@ -> sunk$
        '''

    def reject(self):
        pass
        """
        X -> X
        @ -> @
        how this happens depends on how I want to handle situation where user hits
        a coord already shot at
        """



    def _add_border(self, brd, n):
        """ adds the grid coordinate display 
        """
        for i,j in zip(range(n), 'ABCDEFGHI'[:n]): # inserting each letter at the start of each list
            brd[i].insert(0,j)

        brd.insert(0, [i for i in '+123456789'[:n+1]]) # inserting a coord list at the beginning 

        return brd 


    def _con(self, entry):
        """converts typed coord to readable coord
        """
        if len(entry) == 2:
            return entry.upper()
        elif len(entry) > 2:
            lst = entry.split()
            if len(lst) == 1:
                return lst[0].upper()
            elif len(lst) == 2:
                entry = str(lst[0] + lst[1])
                return entry.upper()
        else:    
            return entry.upper()


'''def display(self):
        """ converts board from a dataset to a displayable board on the CLI console
            and prints it
        """
        abrd = self._add_border(self.BOARD)
        dbrd = self._add_border(self.BOARD)

        print '\t' + 'ATTACK'
        for row in abrd:                   
            print '\t\t' + ' '.join(row)

        print '\t' + 'DEFEND'
        for row in dbrd:
            print '\t\t' + ' '.join(row)


    def _add_border(self, tbrd):
        """ adds the grid coordinates to display 
        """
        for i,j in zip(range(self.n), 'ABCDEFGHI'[:self.n]): # inserting each letter at the start of each list
            tbrd[i].insert(0,j)

        tbrd.insert(0, [i for i in '+123456789'[:self.n+1]]) # inserting a coord list at the beginning 

        return tbrd'''